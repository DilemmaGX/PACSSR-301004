<!DOCTYPE html>
<html lang="en">
   <head>
      <title>STL loader</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
      <script src="https://unpkg.com/three@0.146.0/build/three.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
      <script src="https://unpkg.com/three@0.146.0/examples/js/loaders/STLLoader.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
      <script src="https://unpkg.com/three@0.146.0/examples/js/controls/OrbitControls.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
      <script src="shaderfrog-runtime.min.js"></script>
   </head>
   <body>


      <script>
        
         const scene = new THREE.Scene(); 
         scene.add(new THREE.AxesHelper(2)); // cmt this out if you like...
         
         const pointlight = new THREE.PointLight(0xec4e46,0.7,0,1.5);
         pointlight.position.set(0, 0, 0);
         const ambientlight = new THREE.AmbientLight( 0xf0af6f, 0.4);
         scene.add(ambientlight);

         scene.add(pointlight);
         
         const camera = new THREE.PerspectiveCamera(
             75,
             window.innerWidth / window.innerHeight,
             0.1,
             10000
         );
         camera.position.z = 150;
         camera.position.x = 150;
        
         const renderer = new THREE.WebGLRenderer();
         renderer.outputEncoding = THREE.sRGBEncoding;
         renderer.setSize(window.innerWidth, window.innerHeight);
         document.body.appendChild(renderer.domElement);
         const controls = new THREE.OrbitControls(camera, renderer.domElement);
         controls.enableDamping = true;
        
         //texture
         const redTexture = new THREE.CubeTextureLoader().load([
             'lantern00.png',
             'lantern00.png',
             'lantern00.png',
             'lantern00.png',
             'lantern00.png',
             'lantern00.png'
         ]);
         redTexture.mapping = THREE.CubeReflectionMapping;

         let rotate_speed = 0;
         const toggleButton = document.createElement('button');
         toggleButton.innerHTML = 'Toggle Rotate Speed';
         toggleButton.style.position = 'fixed';
         toggleButton.style.bottom = '10px';
         toggleButton.style.right = '10px';
         toggleButton.addEventListener('click', () => {
             rotate_speed = 1-rotate_speed;
         });
         document.body.appendChild(toggleButton);
         
         let material;
         
         lanternBodyText = new THREE.MeshPhysicalMaterial({
             color: 0xe63223,
             envMap: redTexture,
             metalness: 0.03,
             roughness: 1.0,
             opacity: 0.9,
             transparent: true,
             transmission: 0.8,
             clearcoat: 1.0,
             clearcoatRoughness: 0.25
         });

         const goldTexture = new THREE.CubeTextureLoader().load([
             'Metal034_1K_Color.png',
             'Metal034_1K_Color.png',
             'Metal034_1K_Color.png',
             'Metal034_1K_Color.png',
             'Metal034_1K_Color.png',
             'Metal034_1K_Color.png'
         ]);
         goldTexture.mapping = THREE.CubeReflectionMapping;
         
         lanternFrameText = new THREE.MeshPhysicalMaterial({
             color: 0xffc90e,
             envMap: goldTexture,
             metalness: 0.4,
             roughness: 0.2,
             opacity: 0.9,
             transparent: false,
             transmission: 0.8,
             clearcoat: 1.0,
             clearcoatRoughness: 0.25
         });

         const woodTexture = new THREE.CubeTextureLoader().load([
             'Wood066_1K_Color.png',
             'Wood066_1K_Color.png',
             'Wood066_1K_Roughness.png',
             'Wood066_1K_Color.png',
             'Wood066_1K_Color.png',
             'Wood066_1K_Color.png'
         ]);
         woodTexture.mapping = THREE.CubeReflectionMapping;
         
         topWoodText = new THREE.MeshPhysicalMaterial({
             color: 0x784315,
             envMap: woodTexture,
             metalness: 0.0,
             roughness: 0.9,
             opacity: 1.0,
             transparent: false,
             transmission: 0.8,
             clearcoat: 1.0,
             clearcoatRoughness: 0.25
         });

         const redStl = new THREE.STLLoader();
         redStl.load(
             'lanternRed.stl',
             function (geometry) {
                 const mesh = new THREE.Mesh(geometry, lanternBodyText)
                 mesh.rotation.x -=1.6;
                 mesh.rotation.z += 0.05;
                 scene.add(mesh)
             },
             (xhr) => {
                 console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
             },
             (error) => {
                 console.log(error)
             }
         );

         const goldStl = new THREE.STLLoader();
         goldStl.load(
             'lanternGold.stl',
             function (geometry) {
                 const mesh = new THREE.Mesh(geometry, lanternFrameText)
                 mesh.rotation.x -=1.6;
                 mesh.rotation.z += 0.05;
                 scene.add(mesh)
             },
             (xhr) => {
                 console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
             },
             (error) => {
                 console.log(error)
             }
         );

         const topWood = new THREE.STLLoader();
         topWood.load(
             'top.stl',
             function (geometry) {
                 const mesh = new THREE.Mesh(geometry, topWoodText)
                 mesh.rotation.x -=1.6;
                 mesh.rotation.z += 0.05;
                 scene.add(mesh)
             },
             (xhr) => {
                 console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
             },
             (error) => {
                 console.log(error)
             }
         );
         window.addEventListener('resize', onWindowResize, false);
         function onWindowResize() {
             camera.aspect = window.innerWidth / window.innerHeight
             camera.updateProjectionMatrix()
             renderer.setSize(window.innerWidth, window.innerHeight)
             render()
         };

        
         function animate() {
             requestAnimationFrame(animate);
             
             controls.update();
             render();
             //stats.update()
         }
         
         function render() {
         
             controls.autoRotate = true;
             controls.autoRotateSpeed = 2.1;
             renderer.render(scene, camera);
         }
         
         animate();
         	
      </script>
   </body>
</html>
